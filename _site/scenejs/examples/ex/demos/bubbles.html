<!DOCTYPE html>
<html lang="en">
<head>
    <title>SceneJS Example</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <style>
        body {
            background: white;
            margin: 0;
            -moz-user-select: -moz-none;
            -khtml-user-select: none;
            -webkit-user-select: none;
        }
    </style>
</head>
<body>

<script src="../../../api/latest/scenejs.js"></script>

<script>

// Point SceneJS to the bundled plugins
SceneJS.setConfigs({
    pluginPath:"../../../api/latest/plugins"
});

var scene;
var bubbles;
var bubbleNames;

createScene();
createBubbles();

function createScene() {
    scene = SceneJS.createScene({
        nodes:[

            // Mouse-orbited camera, implemented by plugin at http://scenejs.org/api/latest/plugins/node/cameras/orbit.js
            {
                type:"cameras/orbit",
                yaw:340,
                pitch:-10,
                zoom:150,
                zoomSensitivity:15,

                nodes:[

                    {
                        type:"lights",
                        lights:[
                            {
                                mode:"ambient",
                                color:{ r:0.7, g:0.7, b:0.9 },
                                diffuse:true,
                                specular:false
                            },
                            {
                                mode:"dir",
                                color:{ r:1.0, g:1.0, b:0.2 },
                                diffuse:true,
                                specular:true,
                                dir:{ x:1.0, y:0.9, z:-0.7 },
                                space:"world"
                            }
                        ],

                        nodes:[
                            {
                                type:"material",
                                baseColor:{ r:0.7, g:0.7, b:0.7 },
                                nodes:[

                                    // Grid ground, implemented by plugin at
                                    // http://scenejs.org/api/latest/plugins/node/prims/grid.js
                                    {
                                        type:"prims/grid",
                                        size:{ x:1000, z:1000 },
                                        xSegments:200,
                                        zSegments:200
                                    }
                                ]
                            },

                            // Cloudy sea skybox, implemented by plugin at
                            // http://scenejs.org/api/latest/plugins/node/skyboxes/miramarClouds.js
                            {
                                type:"skyboxes/cloudySea"
                            },

                            //--------------------------------------------------------------------------------
                            // Bubbles
                            //--------------------------------------------------------------------------------

                            // Shader node, injects custom functions into the SceneJS fragment shader
                            // for a cool X-Ray transparency effect
                            {
                                type:"shader",
                                id:"myShader",

                                "shaders":[

                                    // We'll just customize the fragment shader
                                    {
                                        "stage":"fragment",
                                        "code":[

                                            // Input for this shader - the degree of opacity from [0..1]
                                            "uniform float  xrayOpacity;",

                                            // User-injected function to intercept the World-space fragment normal
                                            "vec3 myworldNormal = vec3(0.0, 0.0,  1.0);",
                                            "void myWorldNormalFunc(vec3 vec) {",
                                            "   myworldNormal = vec;",
                                            "}",

                                            // User-injected function to intercept the World-space fragment-eye vector
                                            "vec3 myworldEyeVec = vec3(0.0, 0.0, -1.0);",
                                            "void myWorldEyeVecFunc(vec3 vec) {",
                                            "   myworldEyeVec = vec;",
                                            "}",

                                            // User-injected function to alter the alpha of the outgoing fragment color,
                                            // in proportion to the angle between the fragment normal and the
                                            // fragment-eye vector
                                            "vec4 myPixelColorFunc(vec4 color) {",
                                            "   color.a = (xrayOpacity + 0.9 - abs(dot(myworldNormal, myworldEyeVec)));",
                                            "   return color;",
                                            "}"
                                        ],

                                        // Bind our injected functions to SceneJS hook points
                                        hooks:{
                                            worldNormal:"myWorldNormalFunc",
                                            worldEyeVec:"myWorldEyeVecFunc",
                                            pixelColor:"myPixelColorFunc"
                                        }
                                    }
                                ],

                                // Provide optional initial value for our input uniform
                                params:{
                                    xrayOpacity:0.3
                                },

                                nodes:[

                                    // Disable backfaces (they look ugly with transparency)
                                    // Enable transparency (causing geometries to go into
                                    // the renderer's transparency bin)
                                    {
                                        type:"flags",
                                        flags:{
                                            transparent:true,
                                            backfaces:false
                                        },
                                        nodes:[

                                            // Oily texture
                                            {
                                                type:"texture",
                                                layers:[
                                                    {
                                                        src:"../../textures/oilySheen.jpg",
                                                        applyTo:"color"
                                                    }
                                                ],
                                                nodes:[

                                                    // Bluish color
                                                    {
                                                        type:"material",
                                                        coreId:"bubble",
                                                        emit:0.1,
                                                        color:{ r:0.9, g:0.8, b:1.0 },
                                                        specularColor:{ r:1.0, g:1.0, b:1.0 },
                                                        specular:1.0,
                                                        shine:10.0,
                                                        nodes:[

                                                            // The bubbles go here
                                                            {
                                                                type:"node",
                                                                id:"content"
                                                            }
                                                        ]
                                                    }
                                                ]
                                            }
                                        ]

                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        ]
    });

}

// Bubble factory

function createBubbles() {

    var num = 100;

    // Get content node asynch because it's a child of the 'cameras/orbit' node,
    // which is loaded from a node type plugin

    scene.getNode("content",
            function (contentNode) {
                bubbles = [];
                bubbleNames = {};
                var bubble;

                for (var i = 0; i < num; i++) {

                    bubble = new (function () {

                        var scale = 0.2 + (Math.random() * 2);

                        this.reset = function () {
                            this.pos = {
                                x:(Math.random() * 20) - 10,
                                y:2,
                                z:(Math.random() * 20) - 10
                            };
                            this.dir = {
                                x:0,
                                y:0.1 + Math.random() * 0.1,
                                z:0
                            };
                            this.age = 0;
                            this.wobbleAge = 0;
                            this.lifeSpan = 10000 + Math.random() * 10000;
                            this.popped = false;
                        };

                        this.reset();

                        var name = "o" + i;
                        this.name = contentNode.addNode({
                            type:"name",
                            name:name
                        });
                        bubbleNames[name] = this;

                        this.translate = this.name.addNode({
                            type:"translate"
                        });
                        this.size = this.translate.addNode({
                            type:"scale",
                            x:scale,
                            y:scale,
                            z:scale
                        });
                        this.rotate = this.size.addNode({
                            type:"rotate",
                            x:Math.random() - 0.5,
                            y:Math.random() - 0.5,
                            z:Math.random() - 0.5,
                            angle:0
                        });
                        this.rotate.addNode(
                                // Sphere geometry node implemented by plugin at http://scenejs.org/api/latest/plugins/node/prims/sphere.js
                                {
                                    type:"prims/sphere"
                                });
                        this.angle = 0;
                        this.angleInc = Math.random() - 0.5;
                    })();

                    bubbles.push(bubble);
                }

                var t = (new Date()).getTime();
                scene.on("tick",
                        function () {
                            var timeNow = (new Date()).getTime();
                            var timeSinceLast = timeNow - t;
                            var bubble;
                            var pos;
                            for (var i = 0; i < num; i++) {

                                bubble = bubbles[i];

                                if (bubble.popped) {
                                    bubble.reset();

                                } else {

                                    bubble.age += timeSinceLast;

                                    pos = bubble.pos;

                                    if (bubble.age > bubble.lifeSpan) {
                                        bubble.reset();
                                    } else {
                                        pos.x += bubble.dir.x;
                                        pos.y += bubble.dir.y;
                                        pos.z += bubble.dir.z;
                                    }
                                }

                                bubble.translate.setXYZ(pos);

                                if (++bubble.wobbleAge > 20 + (Math.random() * 10)) {
                                    bubble.dir.x += (Math.random() - 0.5) * 0.1;
                                    bubble.dir.z += (Math.random() - 0.5) * 0.1;
                                    bubble.wobbleAge = 0;
                                }

                                bubble.rotate.setAngle(bubble.angle += bubble.angleInc);
                            }
                            t = timeNow;
                        });
            });
}

// Bubble pick handler, sets bubbles into 'popped' state when picked

scene.on("pick",
        function (params) {
            var bubble = bubbleNames[params.name];
            bubble.popped = true;
        });

</script>
</body>
</html>